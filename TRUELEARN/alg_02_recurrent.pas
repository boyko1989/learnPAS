program recurrent;
{
    Программма расчёта n-го члена последовательности, задаваемой реккурентным соотношением. Так как номер искомого её члена заранее неизвестен, то массив, в котором буду храниться вычисляемые значения вычислять "с запасом".

    Недостаток: хотя нас интересует лишь n-ый член последовательности от 1 до n-го , в памяти хранится вся последовательность.


const
    k = 100;                    // Константа - размер массива
var
    a: array[1..k] of integer;  // массив
    i, n: integer;              // диапазон значений
begin
    readln(n);
    a[1] := 2; // Первый член последовательности
    for i = 2 to n do begin
        a[i] := 2 * a[i - 1] - 1; // очередные члены последовательности
    end;
    // Вывод результата или его использование в рачсчётах , a[n]
end.}

{
    Второй вариант: если для вычисления следующего значения нужно знать только значение предыдущего элемента, то не нужно запоминать все члены последовательности в масссиве. Например, можно иметь переменную a  и при увеличении номера i изменять её значение (для примера выше выражение: a := 2 * a - 1)


var
    a, i, n: integer;
begin
    readln(n);
    a := 2;
    for i := 2 to n do 
        a := 2 * a - 1;
    writeln(a)
end.}

//   ---    ПОСЛЕДОВАТЛЕНОСТЬ ФИБОННАЧЧИ   ---   //

var
    n,                      // номер искомого члена последовательности
    i,                      // счётчик
    regular,                // очередной расчитываемый элемент последовательности
    prior,                  // элемент, предшествующий очередному элементу 
    priprior: integer;      // элемент, предшествующий элементу prior
begin
    readln(n);
    prior := 1;
    priprior := 1;
    for i = 1 to n - 2 do begin        
        regular := prior + priprior;
        priprior := prior;
        prior := regular;
    end;
    writeln(regular)
end.